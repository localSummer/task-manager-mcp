# 任务管理 Prompt 规则

## 1. 目标

本规则旨在指导如何系统地获取、执行任务，并实时同步任务状态和结果，确保任务管理流程高效、可靠且可追溯。

**🚨 强制性检查点（MANDATORY CHECKPOINT）**:

- **每个任务完成时必须创建任务记录文件**: 这是**不可妥协的强制性要求**
- **目标路径**: `{{{tasksResultOutputDir}}}/YYYYMMDDHHmmss-[taskNumber]-[taskKey].md`
- **🕐 时间戳获取验证**: 在创建任务记录文件前，必须先执行 `date '+%Y%m%d%H%M%S'` 命令获取当前实时时间戳，验证格式为 14 位数字后再进行文件创建
- **检查机制**: 每次调用 `set_task_status` 将状态设为 "done" 后，必须立即验证记录文件是否成功创建
- **失败处理**: 如果时间戳获取或记录文件创建失败，必须重试或报告错误，不得继续下一个任务

**核心执行策略**:

- 顶级父任务需要用户交互确认才能开始执行
- 一旦确认执行，该顶级父任务及其所有子任务将自动化连续递归执行，无需额外的用户交互
- 顶级父任务完成后，再次等待用户确认下一个顶级父任务，直到全部任务执行完毕

**重要**:

- 对于顶级父任务，获取到任务后必须等待用户交互确认才能开始执行
- 一旦用户确认执行顶级父任务，该任务及其所有子任务将自动化连续递归执行，无需再次人工交互
- 顶级父任务完成后，再次等待用户交互确认下一个顶级父任务
- 每次顶级父任务执行完成且没有剩余问题时，必须根据当前状态提供相应的用户交互提示。

具体的用户交互控制逻辑、命令处理和状态判断，请参考第 6 节"用户交互控制"的详细说明。

## 2. 核心处理流程

### 2.1. 任务选择与初始化

1. **选择待处理任务**:
   使用 `task-manager-mcp` 中的 `next_task` tool 获取下一个待执行的任务。`next_task` 工具会智能返回下一个应该执行的任务，可能是顶级父任务或子任务，工具内部会处理任务优先级和依赖关系。
2. **任务类型判断与初始化**：
   - **如果获取到的是顶级父任务**: 等待用户确认是否开始执行。在用户确认之前，任务状态应保持为 "pending"。
   - **如果获取到的是子任务**: 自动化开始执行，无需用户交互确认。
   - **判断方法**: 通过任务的层级结构或任务 ID 格式来区分（例如，父任务 ID 为 "1"，子任务 ID 为 "1.1"）。

**核心原则**: 用户确认仅针对顶级父任务的开始，一旦确认执行，将进入自动化执行模式，持续调用 `next_task` 处理该父任务及其所有子任务，直到完成。

### 2.2. 任务执行与状态更新

任务执行流程对于顶级父任务和子任务是完全一致的，唯一区别在于用户交互确认：

- **顶级父任务**: 需要用户确认后开始执行
- **子任务**: 自动化开始执行，无需用户交互确认

#### 通用任务执行流程：

1.  **开始执行**:

    - **更新任务状态**: 在任务开始执行时，使用 `task-manager-mcp` 中的 `set_task_status` tool 立即将当前任务的 `status` 修改为 "in-progress"。确保状态更新操作的原子性，避免数据不一致。
    - **获取执行指令**:
      - 检查当前任务的 `details` 字段。
      - **如果 `details` 字段的值是一个文件路径** (例如，以 `/` 开头，或包含常见的路径分隔符，并指向一个 `.md` 或 `.txt` 文件等)，则读取该文件的全部内容。这些内容将作为执行任务的详细指令。确保文件路径有效且文件可读。
      - **如果 `details` 字段的值不是文件路径**，则直接将其内容作为执行任务的详细指令。
    - **执行操作**: 根据当前任务的 `title`, `description`, 和获取到的执行指令来执行具体任务。确保任务执行过程中的日志记录，以便后续调试和追踪。

2.  **继续处理后续任务 (自动化执行模式)**:

    - **执行模式判断**: 如果当前任务是顶级父任务且用户已确认执行，则进入自动化执行模式。
    - **子任务优先原则**: 在自动化执行模式中，如果当前任务的 `subtasks` 数组不为空，并且其中包含 `status` 不为 "done" 的子任务，则应优先递归处理这些子任务。
    - **自动化循环**: 这一优先处理过程通过持续调用 `next_task` tool 实现。当前任务完成后，开始执行任务完成流程，然后立即调用 `next_task` 获取下一个任务（优先是子任务）并自动执行。
    - **智能任务调度**: `next_task` 工具的内部逻辑确保了子任务的优先处理：
      - 如果父任务有未完成的子任务，优先返回子任务。
      - 如果所有子任务已完成，返回父任务进行最终处理。
      - 如果当前任务组已完成，返回下一个顶级父任务或无任务。
    - **执行一致性**: 所有任务（父任务或子任务）都遵循相同的执行流程、状态更新逻辑和任务结果记录。
    - **终止条件**: 当 `next_task` 返回的不是子任务时，退出自动化执行模式，等待用户交互。

3.  **任务完成（强制执行）**:

    - **收集结果**: 当任务成功执行完毕后，收集所有相关的输出、日志、产物等。确保结果的完整性和准确性。
    - **格式化结果**: 将收集到的所有结果信息转换为一个单一的字符串。确保结果格式化过程的规范性。
    - **更新结果与状态**:
      - 将格式化后的结果字符串赋值给当前任务的 `result` 字段。
      - 使用 `task-manager-mcp` 中的 `set_task_status` tool 将任务的 `status` 修改为 "done"。确保状态更新操作的原子性。
    - **🚨 MANDATORY: 创建任务记录文件（必须执行）**: 当任务状态成功更新为 "done" 后，**必须立即创建任务记录文件**，这是任务完成流程的**强制性要求**，不可跳过：

      - **⚠️ 重要**: 任务记录文件的创建是**每个任务完成的必要条件**，如果未创建记录文件，则认为任务未真正完成
      - **目标目录**: 确保 `{{{tasksResultOutputDir}}}` 目录存在，如不存在则必须创建（包括父目录）
      - **文件命名**: 使用格式 `YYYYMMDDHHmmss-[taskNumber]-[taskKey].md`
        - **时间戳获取**: 必须使用系统命令 `date '+%Y%m%d%H%M%S'` 获取当前实时时间戳
        - **格式要求**: 确保时间戳输出为紧密的 14 位数字格式（如：20241219143025）
        - **执行方式**: 通过命令行调用获取，确保时间的实时性和准确性
        - **备用方案**: 如果系统命令执行失败，使用 JavaScript 的 `new Date()` 方法并格式化为相同的紧密格式
        - taskNumber 为任务的 number 字段（如 "1" 或 "1.1"）
        - taskKey 为任务的 key 字段
      - **文件内容**: 创建包含以下标准格式的 Markdown 文件：

        ```markdown
        # 任务记录: [taskTitle]

        **任务信息**:

        - 任务编号: [taskNumber]
        - 任务标识: [taskKey]
        - 任务描述: [taskDescription]
        - 任务详情: [taskDetails]
        - 完成时间: [通过 date '+%Y%m%d%H%M%S' 获取的当前时间戳]

        ## 更改内容

        [列出在此任务中修改的文件和代码更改摘要]

        ## 更改摘要

        [基于任务执行结果，简要描述主要更改的摘要]

        ## 更改原因

        [基于任务的 description 和执行过程，说明进行这些更改的原因]

        ## 阻碍因素

        [列出在任务执行过程中遇到的阻碍因素，如果没有则标注"无"]

        ## 任务状态

        [根据任务完成情况标注：成功|不成功|未确认]
        ```

      - **严格要求**: 每次任务状态更新为 "done" 后，**必须验证任务记录文件是否成功创建**，如果创建失败，必须重试或报告错误
      - **时间戳获取错误处理**: 如果 `date '+%Y%m%d%H%M%S'` 命令执行失败，立即使用 JavaScript 备用方案：`new Date().toISOString().replace(/[-T:\.Z]/g, '').slice(0, 14)`
      - **格式验证**: 确保获取的时间戳严格为 14 位数字格式，如果格式不正确必须重新获取
      - **质量控制**: 任务记录文件必须包含完整的更改信息、原因说明和状态标注，内容不得为空或敷衍

    - **保存变更**: 确保这些变动被保存。建议在每次状态变更或结果记录后，立即同步数据至持久化存储。

4.  **任务失败或延迟**:
    - **失败处理**: 如果任务执行失败，记录失败原因。
      - 使用 `task-manager-mcp` 中的 `set_task_status` tool 将任务的 `status` 修改为 "pending" (如果可以重试) 或 "deferred" (如果需要人工干预或条件不满足)。
      - 可以在 `result` 字段中记录简要的失败信息或错误日志。确保错误信息的详细性和准确性。
    - **延迟处理**: 如果任务因外部条件无法立即执行，使用 `task-manager-mcp` 中的 `set_task_status` tool 将 `status` 修改为 "deferred"。确保延迟原因的记录清晰明确。
    - **保存变更**: 确保这些变动被保存。建议在每次状态变更或结果记录后，立即同步数据至持久化存储。

### 2.3. 循环与终止

1.  **继续下一个任务**: 当前任务处理完毕（无论是 "done", "deferred"）后，返回到 **2.1. 任务选择与初始化** 步骤，使用 `next_task` tool 选择并处理下一个可用的任务（可能是顶级父任务或子任务）。确保任务处理的连续性和完整性。
2.  **终止条件**: 当使用 `task-manager-mcp` 中的 `next_task` tool 没有获取到更多可执行的任务时（例如，剩下的都是 "deferred" 且无法立即处理的任务），则整个任务管理流程结束。确保终止条件的明确性和合理性。

## 3. 输出

- 每一个更新后的任务中包含最终 `status` 和 `result`。确保输出的完整性和准确性，便于后续的审核和追溯。

## 4. 重要注意事项

- **原子性更新**: 对每一个任务的修改（尤其是 `status` 和 `result` 字段）应该是原子操作，或者有机制确保数据的一致性。在每次状态变更或结果记录后，都应立即保存文件。确保数据操作的可靠性和一致性。
- **日志记录**: 建议在任务执行的各个阶段（开始、结束、失败）记录详细日志，这有助于调试和追踪。虽然 `result` 字段保存最终结果，但过程日志也很重要。确保日志记录的详细性和规范性。
- **错误处理**: 明确任务执行失败时的具体处理逻辑，包括如何记录错误信息以及是否需要重试。确保错误处理机制的合理性和有效性。
- **幂等性**: 如果可能，任务的执行应设计为幂等的，即多次执行同一个已完成的任务不会产生副作用或改变最终结果。确保任务执行的幂等性，避免重复操作带来的问题。
- **🚨 任务记录归档（强制要求）**: 每个完成的任务都**必须**创建对应的记录文件，这是**任务管理的强制性要求**。任务记录文件应包含完整的更改信息、原因说明和状态标注。确保记录文件的格式规范性和内容完整性。**重要：如果任务记录文件创建失败，必须重试直到成功，否则任务不能视为真正完成**。
- **用户交互**:
  - 对于顶级父任务，需要明确的用户确认提示和等待机制。确保用户交互的友好性和清晰性。
  - 对于子任务，应实现自动化连续递归执行，避免重复的用户确认中断流程。
  - 一旦用户确认执行顶级父任务，整个任务群组（父任务+所有子任务）应无缝自动化执行。

## 5. Prompt 示例 (与 AI 助手交互时)

**获取待执行任务:**
使用 `task-manager-mcp` 中的 `next_task` tool 获取下一个待执行的任务（顶级父任务或子任务）。确保任务获取过程无误，避免重复获取或遗漏任务。

**开始执行任务时:**

- 使用 `task-manager-mcp` 中的 `set_task_status` tool 立即将当前任务的 `status` 修改为 "in-progress"。确保状态更新操作的原子性。
- 根据任务指令开始执行任务。确保任务执行过程中的日志记录，以便后续调试和追踪。
- **注意**: 顶级父任务需要用户确认后开始执行，子任务自动化执行无需用户确认。

**任务执行中/后（强制执行记录文件创建）:**
"任务 [任务 KEY/标题] 已执行。请将以下执行结果进行汇总，并更新该任务的 `result` 字段。同时，使用 `task-manager-mcp` 中的 `set_task_status` tool 立即将当前任务的 `status` 修改为 "done"。
**🚨 MANDATORY: 任务状态更新完成后，必须立即执行以下步骤创建任务记录文件**：

1. **首先执行命令** `date '+%Y%m%d%H%M%S'` **获取当前实时时间戳**（格式如：20241219143025）
2. **然后创建格式为** `[获取的时间戳]-[taskNumber]-[taskKey].md` **的任务记录文件**
3. **在** `{{{tasksResultOutputDir}}}` **目录中保存该文件**，这是任务完成的强制性要求，不可跳过或省略。"

**处理依赖:**
"任务 [任务 KEY/标题] 依赖于任务 [依赖任务 KEY/标题]。请先检查前置依赖任务 `precondition` 的状态。如果依赖任务未完成，请先处理依赖任务。" 确保依赖任务的处理逻辑清晰明确。

**自动化处理子任务:**
"顶级父任务 [父任务 KEY/标题] 包含子任务。请在自动化执行模式下，持续调用 `next_task` tool 获取并处理其未完成的子任务，无需等待用户确认。对于每个子任务，请遵循统一的任务处理流程（3.1 和 3.2 节），包括状态更新、前置依赖检查和结果记录。" 确保子任务的自动化处理逻辑与父任务一致。

## 6. 用户交互控制

### 6.1. 命令说明

- **execute**: 开始执行当前已获取到的顶级父任务及其所有子任务，按照 2.2 节的流程进行自动化连续执行
- **next**: 获取下一个待执行的顶级父任务，相当于执行 2.1 节的任务选择流程
- **reset**: 重置整个项目状态，清除所有任务数据并重新初始化

### 6.2. 交互时机

在以下情况下必须提供用户交互选项：

1. 成功获取到待执行的顶级父任务后
2. 顶级父任务（及其所有子任务）执行完成后（无论成功或失败）
3. 任何工具调用完成且系统处于等待状态时

**注意**: 子任务执行过程中不需要用户交互，应自动化连续执行。

### 6.3. 交互格式

根据当前是否存在待执行任务，使用以下不同的交互格式：

**当前存在待执行顶级父任务时：**

```
请选择下一步操作：
- 输入 execute 开始执行当前获取到的顶级父任务及其所有子任务（自动化连续执行）
- 输入 reset 则调用 `task-manager-mcp` 中的 `initialize_project` tool 初始化并重置项目
```

**当前没有待执行顶级父任务时：**

```
请选择下一步操作：
- 输入 next 则调用 `task-manager-mcp` 中的 `next_task` tool 获取下一个待执行的顶级父任务
- 输入 reset 则调用 `task-manager-mcp` 中的 `initialize_project` tool 初始化并重置项目
```

### 6.4. 命令处理逻辑

```
if (用户输入 == "execute") {
  if (当前存在待执行顶级父任务) {
    进入自动化执行模式;
    执行当前顶级父任务（2.2 节）;
    while (next_task 返回子任务) {
      自动执行子任务（2.2 节）;
    }
    退出自动化执行模式;
    显示相应交互选项;
  } else {
    提示错误: "当前没有待执行顶级父任务，请先获取任务";
    重新显示交互选项;
  }
} else if (用户输入 == "next") {
  调用 next_task tool 获取新任务;
  if (获取到顶级父任务) {
    显示任务信息;
    提供 execute 和 reset 选项;
  } else {
    提示: "没有更多可执行的顶级父任务";
    提供 reset 选项;
  }
} else if (用户输入 == "reset") {
  调用 initialize_project tool 重置项目;
  提示: "项目已重置";
  提供 next 和 reset 选项;
}
```

### 6.5. 状态判断逻辑

**执行状态管理**：

系统包含两种主要状态：

- **等待状态**: 等待用户输入命令
- **执行状态**: 自动化执行任务（仅在用户确认顶级父任务后进入）

**简化的状态判断**：

```
当前是否存在待执行顶级父任务:
  = 刚刚通过 next_task 成功获取到顶级父任务 && 尚未执行

执行模式状态转换:
1. 初始状态: 等待状态 (无待执行任务)
2. 调用 next_task → 如果获取到顶级父任务 → 等待状态 (有待执行任务)
3. 用户输入 execute → 执行状态 (自动化执行父任务和所有子任务)
4. 所有任务完成 → 等待状态 (无待执行任务)
```

**关键简化原则**：

- `next_task` 工具内部处理任务调度逻辑，外部只需根据返回结果判断任务类型
- 状态只区分"是否有待执行顶级父任务"和"是否在执行状态"
- 子任务执行过程完全自动化，不影响状态判断
